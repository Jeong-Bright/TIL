- Reference
    - C언어에서 어떠한 변수를 가리키고 싶을 때는 반드시 포인터를 사용해야만 했음
    - C++에서는 다른 변수나 상수를 가리키는 방법으로 또 다른 방식을 제공하는데 이를 바로 참조자라고 부른다.

----

```cpp
#include <iostream>
using namespace std;

int main() {
    int T = 2;
    int& an_T = a;

    an_T = 3;
    cout << "T = " << T << '\n';
    cout << "an_T = " << an_T << '\n';
}
- res / a = 3 an_T = 3

```
# 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 한다.

- int형의 변수 T를 선언하고, 값을 넣어주었다.
- 그 후 T의 참조자 an_T를 정의하였다. 참조자를 정하는 방법은 가리키고자 하는 타입 뒤에 &를 붙이면 된다.
- 위의 코드와 같이 an_T는 T의 참조자이다. 이말은 an_T는 T의 또다른 이름이라고 *컴파일러에게 알려주는 것, 즉 an_T에 어떤 작업을 수행하든 T에 그 작업을 하는 것과 마찬가지 
- 따라서 위의 an_T에 3를 대입하였지만 실제로 T의 값을 확인해보면 3이 들어간 것을 확인할 수 있다.
> compiler : 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 프로그램을 말한다.

    ```cpp
    int& an_T; <- (X)
    int* p; <- (O)
    ```

   - 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
   - 레퍼런스의 또 한 가지 중요한 특징으로 한 번 어떤 변수의 참조자가 되어버린다면, 더 이상 다른 변수를 참조할 수 없게 된다.
    
```c++
    int T = 10;
    int& an_T = T;

    int b = 15;
    an_T = b; 
```

- an_T = b;는, an_T에게 b를 가리키라 명령하는 것이 아니고, T에 b의 값을 대입하라는 의미이다.
- an_T에 무언가를 하는 것은 T에 무언가를 하는 것과 동일하다 했으므로 이 문장은 T = b와 동치

> 포인터는 누구를 가리키는지 자유롭게 바뀔 수 있다.
>> 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.
>>> int a = 10; int* p = &a; // p는 메모리상에서 8byte를 차지하게 됨
>>> int a = 10; int& an_a = a // 컴파일러가 an_a를 위해 메모리 상에 공간을 할당할 필요는 없다. 왜냐면 an_a가 쓰이는 자리는 모두 a로 바꿔치기 하면 되기 때문 / 예외는 존재한다
----
# 여러가지 참조자 예시들

```C++
#include <iostream>

int change_val(int &p) {
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(number);
  std::cout << number << std::endl;
}
```

- 위와같이 참조자 p에게 앞으로 number의 새로운 별명이라고 알려주게 됨, 여기서 중요한 점은 포인터가 인자일 때와는 다르게 number앞에 &를 붙일 필요가 없다는 점이다.
- 이는 참조자를 정의할 때 int&a = b와 한 것 같이 일맥상통 한다.

```cpp
int x;
int& y = x;
int& z = y;
```
- C++ 문법상 참조자의 참조자를 만드는 것은 금지되어 있다. 위의 문장은 x의 참조자를 선언해라와 같은 의미여서, z역시 x의 참조자가 된다. 즉 y와 z모두 x의 참조자가 된다.
----

## cin
    - scanf / cin
    - scanf로 이용할 때에, scanf("%d", &user_input);과 같이 주소값을 전달해주었다.
    - cin은, cin >> user_input이어도 잘 동작한다.
    - 왜냐하면 cin이 reference로 user_input을 받아서 그러함

----

```cpp
#include <iostream>

int main() {
  int &ref = 4;

  std::cout << ref << std::endl;
}
```
- 위와 같은 소스코드에서 컴파일을 하면, 오류가 난다. 왜냐하면 상수 값 자체는 리터럴이기 때문에 위와같이 레퍼런스로 참조한다면 ref = 5; 이런 식으로 리터럴의 값을 바꾸는 행위가 가능하게 됨
> 리터럴(literal)이란, 소스 코드 상에서 고정된 값을 가지는 것을 일컫는다.
- 그 대신에 상수 참조자로 선언한다면 리터럴도 참조할 수 있다. ex) const int &ref = 4; / int a = ref; 는, a = 4와 같은 문장과 동일하게 처리됨

# 레퍼런스의 배열과 배열의 레퍼런스
    - 레퍼런스의 배열을 불법(illegal)이라고 한다. C++ 규정에도 존재할 수 없다고 써져있음
    - C++ 상에서 배열이 어떤 식으로 처리되는지 생각해보면, 배열의 이름은 (arr) 첫 번째 원소의 주소값으로 변환이 될 수 있어야 함, 
    이 때문에 arr[1]과 같은 문장이 *(arr+1)로 바뀌어서 처리될 수 있기 때문이다.
    - 그런데 주소값이 존재한다라는 의미는 해당 원소가 메모리 상에서 존재한다라는 의미와 같다. 
    하지만 레퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지하지 않음, 
    이러한 모순때문에 레퍼런스들의 배열을 정의하는 것은 언어 차원에서 금지되어 있는 것
    - 아예 불가능 한 것은 아닌데, 아래의 코드를 보면
```Cpp
#include <iostream>

int main() {
  int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;

  ref[0] = 2;
  ref[1] = 3;
  ref[2] = 1;

  std::cout << arr[0] << arr[1] << arr[2] << std::endl;
  return 0;
}
```
- ref가 arr을 참조하도록 하였다. 따라서 ref[0]부터 ref[2]가 각각 arr[0]부터 arr[2]의 레퍼런스가 됨, 포인터와는 다르게 배열의 레퍼런스의 경우 참조하기 위해선 반드시 배열의 크기를 명시해야 함

- 따라서 int (&ref)[3] 이라면 크기가 3인 int 배열의 별명이 되어야 하고 int(&ref)[5] 라면 크기가 5인 int 배열의 별명이 되어야 함
----
# 레퍼런스를 리턴하는 함수
    ```cpp
    int function() {
    int a = 2;
    return a;
    }

    int main() {
    int b = function();
    return 0;
    }
```
- int b에서, function 안에 정의된 a라는 변수의 값이 b에 복사되었다. 
- 주목해야할 점은 복사되었다는 점인데, function이 종료되고 나면 a는 메모리에서 사라지게 되고, 더이상 main 안에서는 a를 만날 길이 없다. 다음 예시를 살펴보자,

```cpp
int& function() {
  int a = 2;
  return a;
}

int main() {
  int b = function();
  b = 3;
  return 0;
}
```
- 컴파일을 한다면 경고가 나오고, 런타임 오류가 발생한다. / function 의 return type은 int&이다. 따라서 참조자를 리턴하게 됨, 
    - 문제는 리턴하는 함수 안에 정의되어있는 a는 함수의 리턴과 함께 사라지게 된다는 점이다. (위의 복사를 생각하면 됨)
- 함수가 레퍼런스를 리턴하면서 원래 참조하고 있던 변수가 이미 사라져버렸으므로 오류가 발생하게 됨, 
    - 쉽게 말해 본체는 이미 사라졌지만 별명만 남아있는 상황
- 따라서 위처럼 레퍼런스를 리턴하는 함수에서 지역 변수의 레퍼런스를 리턴하지 않도록 조심해야 함
----
## 외부 변수의 레퍼런스를 리턴
    ```cpp
    int& function(int& a) {
    a = 5;
    return a;
    }

    int main() {
    int b = 2;
    int c = function(b);
    return 0;
}
```

- 이 함수 역시 레퍼런스를 리턴하고 있다. 아까와의 차이점은 위와 같이 인자로 받은 레퍼런스를 그대로 리턴하고 있음
- function(b)를 실행한 시점에서 a는 main의 b를 참조하고 있게 됨, 따라서 function이 리턴한 참조자는 아직 살아있는 변수인 b를 계속 참조함
- 결국 int c는 c에 현재의 b의 값인 5를 대입하는 것과 동일한 문장이 됨

> 그렇다면 참조자를 리턴하는 경우 장점이 무엇일까, C언어에서 엄청나게 큰 구조체가 있을 때 해당 구조체 변수를 그냥 리턴하면 전체 복사가 발생해야 해서 시간이 오래 걸리지만, 해당 구조체를 가리키는 포인터를 리턴한다면 포인터 주소 복사 한번으로 매우 빠르게 끝난다. 마찬가지로 레퍼런스를 리턴하게 된다면 레퍼런스가 참조하는 타입의 크기와 상관 없이 딱 한번의 주소값 복사로 전달이 끝나게 됨

    - 참조자가 아닌 값을 리턴하는 함수를 참조자로 받는다면, 오류가 발생, 
      컴파일 오류에서, 상수가 아닌 레퍼런스가 함수의 리턴값을 참조할 수 없다는 말이 나옴
    - 왜 참조할 수 없을까, 아까전 상황과 마찬가지로 함수의 리턴값은 해당 문장이 끝난 후 바로 사라지는 값이기 때문에 
      참조자를 만들게 되면 바로 다음에 아까와 같이 별명만 남는, 그런 상황이 됨
    - 만약 참조자로 받는 변수에 상수로 선언하면, 문제없이 컴파일이 된다. 
      예외적으로 상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장된다, 그 기간은 레퍼런스가 사라질 때까지이다.

- 정리
    - 값 타입으로 받음(int a = f()) -> (함수에서 값 리턴) 값 복사됨 -> (함수에서 참조자 리턴) 값 복사됨. 다만 지역 변수의 레퍼런스를 리턴하지 않도록 주의
    - 참조자 타입으로 받음 (int& a = f()) -> (함수에서 값 리턴) 컴파일 오류 -> (함수에서 참조자 리턴) 가능. 다만 마찬가지로 지역 변수의 레퍼런스를 리턴하지 않도록 주의
    - 상수 참조자 타입으로 받음 (const int& a = f()) -> (함수에서 값 리턴) 가능 -> (함수에서 참조자 리턴) 가능. 다만 마찬가지로 지역 변수의 레퍼런스를 리턴하지 않도록 주의

----
> 레퍼런스가 메모리 상에 반드시 존재해야하는 경우? / 메모리 상에 존재할 필요가 없는 경우?
>> 정답
>>> 존재해야하는 경우 : 파라미터(매개변수)로 사용될 경우, class또는 struct의 멤버로 참조자가 사용될 경우 // 아닐 수도 ? 잘 모름
>>> 존재하지 않아도 되는 경우 : 같은 함수에 있는 어떤 변수의 참조자가 되었을 때

[참고](https://modoocode.com/141)











